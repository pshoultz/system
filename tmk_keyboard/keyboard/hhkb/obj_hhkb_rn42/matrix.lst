   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.KEY_POWER_OFF,"ax",@progbits
  12               	KEY_POWER_OFF:
  13               	.LFB13:
  14               		.file 1 "hhkb_avr.h"
   1:hhkb_avr.h    **** #ifndef HHKB_AVR_H
   2:hhkb_avr.h    **** #define HHKB_AVR_H
   3:hhkb_avr.h    **** 
   4:hhkb_avr.h    **** #include <stdint.h>
   5:hhkb_avr.h    **** #include <stdbool.h>
   6:hhkb_avr.h    **** #include <avr/io.h>
   7:hhkb_avr.h    **** #include <avr/interrupt.h>
   8:hhkb_avr.h    **** #include <util/delay.h>
   9:hhkb_avr.h    **** 
  10:hhkb_avr.h    **** 
  11:hhkb_avr.h    **** // Timer resolution check
  12:hhkb_avr.h    **** #if (1000000/TIMER_RAW_FREQ > 20)
  13:hhkb_avr.h    **** #   error "Timer resolution(>20us) is not enough for HHKB matrix scan tweak on V-USB."
  14:hhkb_avr.h    **** #endif
  15:hhkb_avr.h    **** 
  16:hhkb_avr.h    **** 
  17:hhkb_avr.h    **** /*
  18:hhkb_avr.h    ****  * HHKB Matrix I/O
  19:hhkb_avr.h    ****  *
  20:hhkb_avr.h    ****  * row:     HC4051[A,B,C]  selects scan row0-7
  21:hhkb_avr.h    ****  * row-ext: [En0,En1] row extention for JP
  22:hhkb_avr.h    ****  * col:     LS145[A,B,C,D] selects scan col0-7 and enable(D)
  23:hhkb_avr.h    ****  * key:     on: 0/off: 1
  24:hhkb_avr.h    ****  * prev:    hysteresis control: assert(1) when previous key state is on
  25:hhkb_avr.h    ****  */
  26:hhkb_avr.h    **** 
  27:hhkb_avr.h    **** 
  28:hhkb_avr.h    **** #if defined(__AVR_ATmega32U4__)
  29:hhkb_avr.h    **** /*
  30:hhkb_avr.h    ****  * For TMK HHKB alt controller(ATMega32U4)
  31:hhkb_avr.h    ****  *
  32:hhkb_avr.h    ****  * row:     PB0-2
  33:hhkb_avr.h    ****  * col:     PB3-5,6
  34:hhkb_avr.h    ****  * key:     PD7(pull-uped)
  35:hhkb_avr.h    ****  * prev:    PB7
  36:hhkb_avr.h    ****  * power:   PD4(L:off/H:on)
  37:hhkb_avr.h    ****  * row-ext: PC6,7 for HHKB JP(active low)
  38:hhkb_avr.h    ****  */
  39:hhkb_avr.h    **** static inline void KEY_ENABLE(void) { (PORTB &= ~(1<<6)); }
  40:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
  41:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
  42:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTB |=  (1<<7)); }
  43:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
  44:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
  45:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {
  46:hhkb_avr.h    ****     DDRB = 0xFF; PORTB = 0x40;          // change pins output
  47:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  48:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  49:hhkb_avr.h    ****     _delay_ms(5);                       // wait for powering up
  50:hhkb_avr.h    **** }
  51:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {
  15               		.loc 1 51 40 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  52:hhkb_avr.h    ****     /* input with pull-up consumes less than without it when pin is open. */
  53:hhkb_avr.h    ****     DDRB = 0x00; PORTB = 0xFF;          // change pins input with pull-up
  21               		.loc 1 53 5 view .LVU1
  22               		.loc 1 53 10 is_stmt 0 view .LVU2
  23 0000 14B8      		out 0x4,__zero_reg__
  24               		.loc 1 53 18 is_stmt 1 view .LVU3
  25               		.loc 1 53 24 is_stmt 0 view .LVU4
  26 0002 8FEF      		ldi r24,lo8(-1)
  27 0004 85B9      		out 0x5,r24
  54:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD &= ~(1<<4);   // MOS FET switch off
  28               		.loc 1 54 5 is_stmt 1 view .LVU5
  29               		.loc 1 54 10 is_stmt 0 view .LVU6
  30 0006 549A      		sbi 0xa,4
  31               		.loc 1 54 21 is_stmt 1 view .LVU7
  32               		.loc 1 54 27 is_stmt 0 view .LVU8
  33 0008 5C98      		cbi 0xb,4
  34               	/* epilogue start */
  55:hhkb_avr.h    **** }
  35               		.loc 1 55 1 view .LVU9
  36 000a 0895      		ret
  37               		.cfi_endproc
  38               	.LFE13:
  40               		.section	.text.KEY_POWER_ON,"ax",@progbits
  42               	KEY_POWER_ON:
  43               	.LFB12:
  45:hhkb_avr.h    ****     DDRB = 0xFF; PORTB = 0x40;          // change pins output
  44               		.loc 1 45 39 is_stmt 1 view -0
  45               		.cfi_startproc
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
  46:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  50               		.loc 1 46 5 view .LVU11
  46:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  51               		.loc 1 46 10 is_stmt 0 view .LVU12
  52 0000 8FEF      		ldi r24,lo8(-1)
  53 0002 84B9      		out 0x4,r24
  46:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  54               		.loc 1 46 18 is_stmt 1 view .LVU13
  46:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  55               		.loc 1 46 24 is_stmt 0 view .LVU14
  56 0004 80E4      		ldi r24,lo8(64)
  57 0006 85B9      		out 0x5,r24
  47:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  58               		.loc 1 47 5 is_stmt 1 view .LVU15
  47:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  59               		.loc 1 47 10 is_stmt 0 view .LVU16
  60 0008 549A      		sbi 0xa,4
  47:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  61               		.loc 1 47 21 is_stmt 1 view .LVU17
  47:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  62               		.loc 1 47 27 is_stmt 0 view .LVU18
  63 000a 5C9A      		sbi 0xb,4
  49:hhkb_avr.h    **** }
  64               		.loc 1 49 5 is_stmt 1 view .LVU19
  65               	.LVL0:
  66               	.LBB32:
  67               	.LBI32:
  68               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
  69               		.loc 2 166 1 view .LVU20
  70               	.LBB33:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
  71               		.loc 2 168 2 view .LVU21
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
  72               		.loc 2 172 2 view .LVU22
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  73               		.loc 2 173 2 view .LVU23
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  74               		.loc 2 174 2 view .LVU24
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  75               		.loc 2 184 3 view .LVU25
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  76               		.loc 2 187 2 view .LVU26
  77 000c 8FE1      		ldi r24,lo8(19999)
  78 000e 9EE4      		ldi r25,hi8(19999)
  79 0010 0197      	1:	sbiw r24,1
  80 0012 01F4      		brne 1b
  81 0014 00C0      		rjmp .
  82 0016 0000      		nop
  83               	.LVL1:
  84               	/* epilogue start */
  85               		.loc 2 187 2 is_stmt 0 view .LVU27
  86               	.LBE33:
  87               	.LBE32:
  50:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {
  88               		.loc 1 50 1 view .LVU28
  89 0018 0895      		ret
  90               		.cfi_endproc
  91               	.LFE12:
  93               		.section	.text.matrix_init,"ax",@progbits
  94               	.global	matrix_init
  96               	matrix_init:
  97               	.LFB115:
  98               		.file 3 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2011 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <util/delay.h>
  24:matrix.c      **** #include "print.h"
  25:matrix.c      **** #include "debug.h"
  26:matrix.c      **** #include "util.h"
  27:matrix.c      **** #include "timer.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** #include "hhkb_avr.h"
  30:matrix.c      **** #include <avr/wdt.h>
  31:matrix.c      **** #include "suspend.h"
  32:matrix.c      **** #include "lufa.h"
  33:matrix.c      **** 
  34:matrix.c      **** 
  35:matrix.c      **** // matrix power saving
  36:matrix.c      **** #define MATRIX_POWER_SAVE       10000
  37:matrix.c      **** static uint32_t matrix_last_modified = 0;
  38:matrix.c      **** 
  39:matrix.c      **** // matrix state buffer(1:on, 0:off)
  40:matrix.c      **** static matrix_row_t *matrix;
  41:matrix.c      **** static matrix_row_t *matrix_prev;
  42:matrix.c      **** static matrix_row_t _matrix0[MATRIX_ROWS];
  43:matrix.c      **** static matrix_row_t _matrix1[MATRIX_ROWS];
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** void matrix_init(void)
  47:matrix.c      **** {
  99               		.loc 3 47 1 is_stmt 1 view -0
 100               		.cfi_startproc
 101               	/* prologue: function */
 102               	/* frame size = 0 */
 103               	/* stack size = 0 */
 104               	.L__stack_usage = 0
  48:matrix.c      **** #ifdef DEBUG
  49:matrix.c      ****     debug_enable = true;
  50:matrix.c      ****     debug_keyboard = true;
  51:matrix.c      **** #endif
  52:matrix.c      **** 
  53:matrix.c      ****     KEY_INIT();
 105               		.loc 3 53 5 view .LVU30
 106               	.LBB42:
 107               	.LBI42:
  56:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return PORTD & (1<<4); }
  57:hhkb_avr.h    **** #else
  58:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {}
  59:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {}
  60:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return true; }
  61:hhkb_avr.h    **** #endif
  62:hhkb_avr.h    **** static inline void KEY_INIT(void)
 108               		.loc 1 62 20 view .LVU31
 109               	.LBB43:
  63:hhkb_avr.h    **** {
  64:hhkb_avr.h    ****     /* row,col,prev: output */
  65:hhkb_avr.h    ****     DDRB  = 0xFF;
 110               		.loc 1 65 5 view .LVU32
 111               		.loc 1 65 11 is_stmt 0 view .LVU33
 112 0000 8FEF      		ldi r24,lo8(-1)
 113 0002 84B9      		out 0x4,r24
  66:hhkb_avr.h    ****     PORTB = 0x40;   // unable
 114               		.loc 1 66 5 is_stmt 1 view .LVU34
 115               		.loc 1 66 11 is_stmt 0 view .LVU35
 116 0004 80E4      		ldi r24,lo8(64)
 117 0006 85B9      		out 0x5,r24
  67:hhkb_avr.h    ****     /* key: input with pull-up */
  68:hhkb_avr.h    ****     DDRD  &= ~0x80;
 118               		.loc 1 68 5 is_stmt 1 view .LVU36
 119               		.loc 1 68 11 is_stmt 0 view .LVU37
 120 0008 5798      		cbi 0xa,7
  69:hhkb_avr.h    ****     PORTD |=  0x80;
 121               		.loc 1 69 5 is_stmt 1 view .LVU38
 122               		.loc 1 69 11 is_stmt 0 view .LVU39
 123 000a 5F9A      		sbi 0xb,7
  70:hhkb_avr.h    **** #ifdef HHKB_JP
  71:hhkb_avr.h    ****     /* row extention for HHKB JP */
  72:hhkb_avr.h    ****     DDRC  |= (1<<6|1<<7);
  73:hhkb_avr.h    ****     PORTC |= (1<<6|1<<7);
  74:hhkb_avr.h    **** #else
  75:hhkb_avr.h    ****     /* input with pull up to save power */
  76:hhkb_avr.h    ****     DDRC  &= ~(1<<6|1<<7);
 124               		.loc 1 76 5 is_stmt 1 view .LVU40
 125               		.loc 1 76 11 is_stmt 0 view .LVU41
 126 000c 87B1      		in r24,0x7
 127 000e 8F73      		andi r24,lo8(63)
 128 0010 87B9      		out 0x7,r24
  77:hhkb_avr.h    ****     PORTC |=  (1<<6|1<<7);
 129               		.loc 1 77 5 is_stmt 1 view .LVU42
 130               		.loc 1 77 11 is_stmt 0 view .LVU43
 131 0012 88B1      		in r24,0x8
 132 0014 806C      		ori r24,lo8(-64)
 133 0016 88B9      		out 0x8,r24
  78:hhkb_avr.h    **** #endif
  79:hhkb_avr.h    ****     KEY_UNABLE();
 134               		.loc 1 79 5 is_stmt 1 view .LVU44
 135               	.LBB44:
 136               	.LBI44:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
 137               		.loc 1 40 20 view .LVU45
 138               	.LBB45:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
 139               		.loc 1 40 39 view .LVU46
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
 140               		.loc 1 40 46 is_stmt 0 view .LVU47
 141 0018 2E9A      		sbi 0x5,6
 142               	.LBE45:
 143               	.LBE44:
  80:hhkb_avr.h    ****     KEY_PREV_OFF();
 144               		.loc 1 80 5 is_stmt 1 view .LVU48
 145               	.LBB46:
 146               	.LBI46:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 147               		.loc 1 43 20 view .LVU49
 148               	.LBB47:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 149               		.loc 1 43 41 view .LVU50
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 150               		.loc 1 43 48 is_stmt 0 view .LVU51
 151 001a 2F98      		cbi 0x5,7
 152               	.LBE47:
 153               	.LBE46:
  81:hhkb_avr.h    **** 
  82:hhkb_avr.h    ****     KEY_POWER_OFF();
 154               		.loc 1 82 5 is_stmt 1 view .LVU52
 155 001c 0E94 0000 		call KEY_POWER_OFF
 156               	.LVL2:
 157               		.loc 1 82 5 is_stmt 0 view .LVU53
 158               	.LBE43:
 159               	.LBE42:
 160               	.LBB48:
  54:matrix.c      **** 
  55:matrix.c      ****     // initialize matrix state: all keys off
  56:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix0[i] = 0x00;
 161               		.loc 3 56 45 is_stmt 1 view .LVU54
 162               		.loc 3 56 57 is_stmt 0 view .LVU55
 163 0020 A0E0      		ldi r26,lo8(_matrix0)
 164 0022 B0E0      		ldi r27,hi8(_matrix0)
 165 0024 1C92      		st X,__zero_reg__
 166               	.LVL3:
 167               		.loc 3 56 45 is_stmt 1 view .LVU56
 168               		.loc 3 56 57 is_stmt 0 view .LVU57
 169 0026 1196      		adiw r26,1
 170 0028 1C92      		st X,__zero_reg__
 171 002a 1197      		sbiw r26,1
 172               	.LVL4:
 173               		.loc 3 56 45 is_stmt 1 view .LVU58
 174               		.loc 3 56 57 is_stmt 0 view .LVU59
 175 002c 1296      		adiw r26,2
 176 002e 1C92      		st X,__zero_reg__
 177 0030 1297      		sbiw r26,2
 178               	.LVL5:
 179               		.loc 3 56 45 is_stmt 1 view .LVU60
 180               		.loc 3 56 57 is_stmt 0 view .LVU61
 181 0032 1396      		adiw r26,3
 182 0034 1C92      		st X,__zero_reg__
 183 0036 1397      		sbiw r26,3
 184               	.LVL6:
 185               		.loc 3 56 45 is_stmt 1 view .LVU62
 186               		.loc 3 56 57 is_stmt 0 view .LVU63
 187 0038 1496      		adiw r26,4
 188 003a 1C92      		st X,__zero_reg__
 189 003c 1497      		sbiw r26,4
 190               	.LVL7:
 191               		.loc 3 56 45 is_stmt 1 view .LVU64
 192               		.loc 3 56 57 is_stmt 0 view .LVU65
 193 003e 1596      		adiw r26,5
 194 0040 1C92      		st X,__zero_reg__
 195 0042 1597      		sbiw r26,5
 196               	.LVL8:
 197               		.loc 3 56 45 is_stmt 1 view .LVU66
 198               		.loc 3 56 57 is_stmt 0 view .LVU67
 199 0044 1696      		adiw r26,6
 200 0046 1C92      		st X,__zero_reg__
 201 0048 1697      		sbiw r26,6
 202               	.LVL9:
 203               		.loc 3 56 45 is_stmt 1 view .LVU68
 204               		.loc 3 56 57 is_stmt 0 view .LVU69
 205 004a 1796      		adiw r26,7
 206 004c 1C92      		st X,__zero_reg__
 207 004e 1797      		sbiw r26,7
 208               	.LVL10:
 209               		.loc 3 56 57 view .LVU70
 210               	.LBE48:
 211               	.LBB49:
  57:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix1[i] = 0x00;
 212               		.loc 3 57 45 is_stmt 1 view .LVU71
 213               		.loc 3 57 57 is_stmt 0 view .LVU72
 214 0050 E0E0      		ldi r30,lo8(_matrix1)
 215 0052 F0E0      		ldi r31,hi8(_matrix1)
 216 0054 1082      		st Z,__zero_reg__
 217               	.LVL11:
 218               		.loc 3 57 45 is_stmt 1 view .LVU73
 219               		.loc 3 57 57 is_stmt 0 view .LVU74
 220 0056 1182      		std Z+1,__zero_reg__
 221               	.LVL12:
 222               		.loc 3 57 45 is_stmt 1 view .LVU75
 223               		.loc 3 57 57 is_stmt 0 view .LVU76
 224 0058 1282      		std Z+2,__zero_reg__
 225               	.LVL13:
 226               		.loc 3 57 45 is_stmt 1 view .LVU77
 227               		.loc 3 57 57 is_stmt 0 view .LVU78
 228 005a 1382      		std Z+3,__zero_reg__
 229               	.LVL14:
 230               		.loc 3 57 45 is_stmt 1 view .LVU79
 231               		.loc 3 57 57 is_stmt 0 view .LVU80
 232 005c 1482      		std Z+4,__zero_reg__
 233               	.LVL15:
 234               		.loc 3 57 45 is_stmt 1 view .LVU81
 235               		.loc 3 57 57 is_stmt 0 view .LVU82
 236 005e 1582      		std Z+5,__zero_reg__
 237               	.LVL16:
 238               		.loc 3 57 45 is_stmt 1 view .LVU83
 239               		.loc 3 57 57 is_stmt 0 view .LVU84
 240 0060 1682      		std Z+6,__zero_reg__
 241               	.LVL17:
 242               		.loc 3 57 45 is_stmt 1 view .LVU85
 243               		.loc 3 57 57 is_stmt 0 view .LVU86
 244 0062 1782      		std Z+7,__zero_reg__
 245               	.LVL18:
 246               		.loc 3 57 57 view .LVU87
 247               	.LBE49:
  58:matrix.c      ****     matrix = _matrix0;
 248               		.loc 3 58 5 is_stmt 1 view .LVU88
 249               		.loc 3 58 12 is_stmt 0 view .LVU89
 250 0064 B093 0000 		sts matrix+1,r27
 251 0068 A093 0000 		sts matrix,r26
  59:matrix.c      ****     matrix_prev = _matrix1;
 252               		.loc 3 59 5 is_stmt 1 view .LVU90
 253               		.loc 3 59 17 is_stmt 0 view .LVU91
 254 006c F093 0000 		sts matrix_prev+1,r31
 255 0070 E093 0000 		sts matrix_prev,r30
 256               	/* epilogue start */
  60:matrix.c      **** }
 257               		.loc 3 60 1 view .LVU92
 258 0074 0895      		ret
 259               		.cfi_endproc
 260               	.LFE115:
 262               		.section	.text.matrix_scan,"ax",@progbits
 263               	.global	matrix_scan
 265               	matrix_scan:
 266               	.LFB116:
  61:matrix.c      **** 
  62:matrix.c      **** uint8_t matrix_scan(void)
  63:matrix.c      **** {
 267               		.loc 3 63 1 is_stmt 1 view -0
 268               		.cfi_startproc
 269 0000 EF92      		push r14
 270               	.LCFI0:
 271               		.cfi_def_cfa_offset 3
 272               		.cfi_offset 14, -2
 273 0002 FF92      		push r15
 274               	.LCFI1:
 275               		.cfi_def_cfa_offset 4
 276               		.cfi_offset 15, -3
 277 0004 0F93      		push r16
 278               	.LCFI2:
 279               		.cfi_def_cfa_offset 5
 280               		.cfi_offset 16, -4
 281 0006 1F93      		push r17
 282               	.LCFI3:
 283               		.cfi_def_cfa_offset 6
 284               		.cfi_offset 17, -5
 285 0008 CF93      		push r28
 286               	.LCFI4:
 287               		.cfi_def_cfa_offset 7
 288               		.cfi_offset 28, -6
 289 000a DF93      		push r29
 290               	.LCFI5:
 291               		.cfi_def_cfa_offset 8
 292               		.cfi_offset 29, -7
 293               	/* prologue: function */
 294               	/* frame size = 0 */
 295               	/* stack size = 6 */
 296               	.L__stack_usage = 6
  64:matrix.c      ****     uint8_t *tmp;
 297               		.loc 3 64 5 view .LVU94
  65:matrix.c      **** 
  66:matrix.c      ****     tmp = matrix_prev;
 298               		.loc 3 66 5 view .LVU95
 299               		.loc 3 66 9 is_stmt 0 view .LVU96
 300 000c 8091 0000 		lds r24,matrix_prev
 301 0010 9091 0000 		lds r25,matrix_prev+1
 302               	.LVL19:
  67:matrix.c      ****     matrix_prev = matrix;
 303               		.loc 3 67 5 is_stmt 1 view .LVU97
 304               		.loc 3 67 17 is_stmt 0 view .LVU98
 305 0014 2091 0000 		lds r18,matrix
 306 0018 3091 0000 		lds r19,matrix+1
 307 001c 3093 0000 		sts matrix_prev+1,r19
 308 0020 2093 0000 		sts matrix_prev,r18
  68:matrix.c      ****     matrix = tmp;
 309               		.loc 3 68 5 is_stmt 1 view .LVU99
 310               		.loc 3 68 12 is_stmt 0 view .LVU100
 311 0024 9093 0000 		sts matrix+1,r25
 312 0028 8093 0000 		sts matrix,r24
  69:matrix.c      **** 
  70:matrix.c      ****     // power on
  71:matrix.c      ****     if (!KEY_POWER_STATE()) KEY_POWER_ON();
 313               		.loc 3 71 5 is_stmt 1 view .LVU101
 314               	.LBB79:
 315               	.LBI79:
  56:hhkb_avr.h    **** #else
 316               		.loc 1 56 20 view .LVU102
 317               	.LBB80:
  56:hhkb_avr.h    **** #else
 318               		.loc 1 56 44 view .LVU103
 319               	.LBE80:
 320               	.LBE79:
 321               		.loc 3 71 8 is_stmt 0 view .LVU104
 322 002c 5C9B      		sbis 0xb,4
 323               		.loc 3 71 29 is_stmt 1 discriminator 1 view .LVU105
 324 002e 0E94 0000 		call KEY_POWER_ON
 325               	.LVL20:
 326               	.L5:
  63:matrix.c      ****     uint8_t *tmp;
 327               		.loc 3 63 1 is_stmt 0 view .LVU106
 328 0032 D0E0      		ldi r29,0
 329 0034 C0E0      		ldi r28,0
 330 0036 01E0      		ldi r16,lo8(1)
 331 0038 10E0      		ldi r17,0
 332               	.LBB81:
 333               	.LBB82:
 334               	.LBB83:
  72:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
  73:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
  74:matrix.c      ****             KEY_SELECT(row, col);
  75:matrix.c      ****             _delay_us(5);
  76:matrix.c      **** 
  77:matrix.c      ****             // Not sure this is needed. This just emulates HHKB controller's behaviour.
  78:matrix.c      ****             if (matrix_prev[row] & (1<<col)) {
  79:matrix.c      ****                 KEY_PREV_ON();
  80:matrix.c      ****             }
  81:matrix.c      ****             _delay_us(10);
  82:matrix.c      **** 
  83:matrix.c      ****             // NOTE: KEY_STATE is valid only in 20us after KEY_ENABLE.
  84:matrix.c      ****             // If V-USB interrupts in this section we could lose 40us or so
  85:matrix.c      ****             // and would read invalid value from KEY_STATE.
  86:matrix.c      ****             uint8_t last = TIMER_RAW;
  87:matrix.c      **** 
  88:matrix.c      ****             KEY_ENABLE();
  89:matrix.c      **** 
  90:matrix.c      ****             // Wait for KEY_STATE outputs its value.
  91:matrix.c      ****             // 1us was ok on one HHKB, but not worked on another.
  92:matrix.c      ****             // no   wait doesn't work on Teensy++ with pro(1us works)
  93:matrix.c      ****             // no   wait does    work on tmk PCB(8MHz) with pro2
  94:matrix.c      ****             // 1us  wait does    work on both of above
  95:matrix.c      ****             // 1us  wait doesn't work on tmk(16MHz)
  96:matrix.c      ****             // 5us  wait does    work on tmk(16MHz)
  97:matrix.c      ****             // 5us  wait does    work on tmk(16MHz/2)
  98:matrix.c      ****             // 5us  wait does    work on tmk(8MHz)
  99:matrix.c      ****             // 10us wait does    work on Teensy++ with pro
 100:matrix.c      ****             // 10us wait does    work on 328p+iwrap with pro
 101:matrix.c      ****             // 10us wait doesn't work on tmk PCB(8MHz) with pro2(very lagged scan)
 102:matrix.c      ****             _delay_us(5);
 103:matrix.c      **** 
 104:matrix.c      ****             if (KEY_STATE()) {
 105:matrix.c      ****                 matrix[row] &= ~(1<<col);
 106:matrix.c      ****             } else {
 107:matrix.c      ****                 matrix[row] |= (1<<col);
 108:matrix.c      ****             }
 109:matrix.c      **** 
 110:matrix.c      ****             // Ignore if this code region execution time elapses more than 20us.
 111:matrix.c      ****             // MEMO: 20[us] * (TIMER_RAW_FREQ / 1000000)[count per us]
 112:matrix.c      ****             // MEMO: then change above using this rule: a/(b/c) = a*1/(b/c) = a*(c/b)
 113:matrix.c      ****             if (TIMER_DIFF_RAW(TIMER_RAW, last) > 20/(1000000/TIMER_RAW_FREQ)) {
 335               		.loc 3 113 17 view .LVU107
 336 003a EE24      		clr r14
 337 003c EA94      		dec r14
 338 003e F12C      		mov r15,__zero_reg__
 339               	.L14:
 340               	.LVL21:
 341               		.loc 3 113 17 view .LVU108
 342               	.LBE83:
 343               	.LBE82:
 344               	.LBE81:
  63:matrix.c      ****     uint8_t *tmp;
 345               		.loc 3 63 1 view .LVU109
 346 0040 60E0      		ldi r22,0
 347 0042 30E0      		ldi r19,0
 348 0044 20E0      		ldi r18,0
 349               	.LVL22:
 350               	.L12:
 351               	.LBB110:
 352               	.LBB108:
 353               	.LBB106:
  74:matrix.c      ****             _delay_us(5);
 354               		.loc 3 74 13 is_stmt 1 view .LVU110
 355               	.LBB84:
 356               	.LBI84:
  83:hhkb_avr.h    **** }
  84:hhkb_avr.h    **** static inline void KEY_SELECT(uint8_t ROW, uint8_t COL)
 357               		.loc 1 84 20 view .LVU111
 358               	.LBB85:
  85:hhkb_avr.h    **** {
  86:hhkb_avr.h    ****     PORTB = (PORTB & 0xC0) | (((COL) & 0x07)<<3) | ((ROW) & 0x07);
 359               		.loc 1 86 5 view .LVU112
 360               		.loc 1 86 14 is_stmt 0 view .LVU113
 361 0046 85B1      		in r24,0x5
 362               		.loc 1 86 45 view .LVU114
 363 0048 422F      		mov r20,r18
 364               		.loc 1 86 20 view .LVU115
 365 004a 807C      		andi r24,lo8(-64)
 366               		.loc 1 86 50 view .LVU116
 367 004c 8C2B      		or r24,r28
 368 004e 862B      		or r24,r22
 369               		.loc 1 86 11 view .LVU117
 370 0050 85B9      		out 0x5,r24
 371               	.LVL23:
 372               		.loc 1 86 11 view .LVU118
 373               	.LBE85:
 374               	.LBE84:
  75:matrix.c      **** 
 375               		.loc 3 75 13 is_stmt 1 view .LVU119
 376               	.LBB86:
 377               	.LBI86:
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 378               		.loc 2 255 1 view .LVU120
 379               	.LBB87:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 380               		.loc 2 257 2 view .LVU121
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 381               		.loc 2 261 2 view .LVU122
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 382               		.loc 2 262 2 view .LVU123
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 383               		.loc 2 263 2 view .LVU124
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 384               		.loc 2 273 3 view .LVU125
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 385               		.loc 2 276 2 view .LVU126
 386 0052 AAE1      		ldi r26,lo8(26)
 387 0054 AA95      	1:	dec r26
 388 0056 01F4      		brne 1b
 389 0058 00C0      		rjmp .
 390               	.LVL24:
 391               		.loc 2 276 2 is_stmt 0 view .LVU127
 392               	.LBE87:
 393               	.LBE86:
  78:matrix.c      ****                 KEY_PREV_ON();
 394               		.loc 3 78 13 is_stmt 1 view .LVU128
  78:matrix.c      ****                 KEY_PREV_ON();
 395               		.loc 3 78 28 is_stmt 0 view .LVU129
 396 005a E091 0000 		lds r30,matrix_prev
 397 005e F091 0000 		lds r31,matrix_prev+1
 398 0062 EC0F      		add r30,r28
 399 0064 FD1F      		adc r31,r29
 400 0066 8081      		ld r24,Z
 401 0068 90E0      		ldi r25,0
  78:matrix.c      ****                 KEY_PREV_ON();
 402               		.loc 3 78 17 view .LVU130
 403 006a 022E      		mov r0,r18
 404 006c 00C0      		rjmp 2f
 405               		1:
 406 006e 9595      		asr r25
 407 0070 8795      		ror r24
 408               		2:
 409 0072 0A94      		dec r0
 410 0074 02F4      		brpl 1b
  78:matrix.c      ****                 KEY_PREV_ON();
 411               		.loc 3 78 16 view .LVU131
 412 0076 80FD      		sbrc r24,0
  79:matrix.c      ****             }
 413               		.loc 3 79 17 is_stmt 1 view .LVU132
 414               	.LBB88:
 415               	.LBI88:
  42:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
 416               		.loc 1 42 20 view .LVU133
 417               	.LBB89:
  42:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
 418               		.loc 1 42 40 view .LVU134
  42:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
 419               		.loc 1 42 47 is_stmt 0 view .LVU135
 420 0078 2F9A      		sbi 0x5,7
 421               	.L6:
 422               	.LBE89:
 423               	.LBE88:
  81:matrix.c      **** 
 424               		.loc 3 81 13 is_stmt 1 view .LVU136
 425               	.LVL25:
 426               	.LBB90:
 427               	.LBI90:
 255:/usr/avr/include/util/delay.h **** {
 428               		.loc 2 255 1 view .LVU137
 429               	.LBB91:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 430               		.loc 2 257 2 view .LVU138
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 431               		.loc 2 261 2 view .LVU139
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 432               		.loc 2 262 2 view .LVU140
 263:/usr/avr/include/util/delay.h **** 
 433               		.loc 2 263 2 view .LVU141
 273:/usr/avr/include/util/delay.h **** 	#endif
 434               		.loc 2 273 3 view .LVU142
 435               		.loc 2 276 2 view .LVU143
 436 007a B5E3      		ldi r27,lo8(53)
 437 007c BA95      	1:	dec r27
 438 007e 01F4      		brne 1b
 439 0080 0000      		nop
 440               	.LVL26:
 441               		.loc 2 276 2 is_stmt 0 view .LVU144
 442               	.LBE91:
 443               	.LBE90:
  86:matrix.c      **** 
 444               		.loc 3 86 13 is_stmt 1 view .LVU145
  86:matrix.c      **** 
 445               		.loc 3 86 21 is_stmt 0 view .LVU146
 446 0082 76B5      		in r23,0x26
 447               	.LVL27:
  88:matrix.c      **** 
 448               		.loc 3 88 13 is_stmt 1 view .LVU147
 449               	.LBB92:
 450               	.LBI92:
  39:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
 451               		.loc 1 39 20 view .LVU148
 452               	.LBB93:
  39:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
 453               		.loc 1 39 39 view .LVU149
  39:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
 454               		.loc 1 39 46 is_stmt 0 view .LVU150
 455 0084 2E98      		cbi 0x5,6
 456               	.LBE93:
 457               	.LBE92:
 102:matrix.c      **** 
 458               		.loc 3 102 13 is_stmt 1 view .LVU151
 459               	.LVL28:
 460               	.LBB94:
 461               	.LBI94:
 255:/usr/avr/include/util/delay.h **** {
 462               		.loc 2 255 1 view .LVU152
 463               	.LBB95:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 464               		.loc 2 257 2 view .LVU153
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 465               		.loc 2 261 2 view .LVU154
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 466               		.loc 2 262 2 view .LVU155
 263:/usr/avr/include/util/delay.h **** 
 467               		.loc 2 263 2 view .LVU156
 273:/usr/avr/include/util/delay.h **** 	#endif
 468               		.loc 2 273 3 view .LVU157
 469               		.loc 2 276 2 view .LVU158
 470 0086 EAE1      		ldi r30,lo8(26)
 471 0088 EA95      	1:	dec r30
 472 008a 01F4      		brne 1b
 473 008c 00C0      		rjmp .
 474               	.LVL29:
 475               		.loc 2 276 2 is_stmt 0 view .LVU159
 476               	.LBE95:
 477               	.LBE94:
 104:matrix.c      ****                 matrix[row] &= ~(1<<col);
 478               		.loc 3 104 13 is_stmt 1 view .LVU160
 479               	.LBB96:
 480               	.LBI96:
  41:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTB |=  (1<<7)); }
 481               		.loc 1 41 20 view .LVU161
 482               	.LBB97:
  41:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTB |=  (1<<7)); }
 483               		.loc 1 41 38 view .LVU162
 484 008e C801      		movw r24,r16
 485 0090 00C0      		rjmp 2f
 486               		1:
 487 0092 880F      		lsl r24
 488               		2:
 489 0094 4A95      		dec r20
 490 0096 02F4      		brpl 1b
 491 0098 4091 0000 		lds r20,matrix
 492 009c 5091 0000 		lds r21,matrix+1
 493               	.LBE97:
 494               	.LBE96:
 105:matrix.c      ****             } else {
 495               		.loc 3 105 29 is_stmt 0 view .LVU163
 496 00a0 FA01      		movw r30,r20
 497 00a2 EC0F      		add r30,r28
 498 00a4 FD1F      		adc r31,r29
 104:matrix.c      ****                 matrix[row] &= ~(1<<col);
 499               		.loc 3 104 16 view .LVU164
 500 00a6 4F9B      		sbis 0x9,7
 501 00a8 00C0      		rjmp .L7
 105:matrix.c      ****             } else {
 502               		.loc 3 105 17 is_stmt 1 view .LVU165
 105:matrix.c      ****             } else {
 503               		.loc 3 105 29 is_stmt 0 view .LVU166
 504 00aa 8095      		com r24
 505 00ac 9081      		ld r25,Z
 506 00ae 8923      		and r24,r25
 507               	.L29:
 107:matrix.c      ****             }
 508               		.loc 3 107 29 view .LVU167
 509 00b0 8083      		st Z,r24
 510               		.loc 3 113 13 is_stmt 1 view .LVU168
 511               		.loc 3 113 17 is_stmt 0 view .LVU169
 512 00b2 86B5      		in r24,0x26
 513 00b4 E72F      		mov r30,r23
 514 00b6 F0E0      		ldi r31,0
 515 00b8 8717      		cp r24,r23
 516 00ba 00F4      		brsh .+2
 517 00bc 00C0      		rjmp .L9
 518               		.loc 3 113 17 discriminator 1 view .LVU170
 519 00be 86B5      		in r24,0x26
 520 00c0 90E0      		ldi r25,0
 521 00c2 8E1B      		sub r24,r30
 522 00c4 9F0B      		sbc r25,r31
 523               	.L10:
 524               		.loc 3 113 16 discriminator 4 view .LVU171
 525 00c6 0697      		sbiw r24,6
 526 00c8 00F0      		brlo .L11
 114:matrix.c      ****                 matrix[row] = matrix_prev[row];
 527               		.loc 3 114 17 is_stmt 1 view .LVU172
 528               		.loc 3 114 42 is_stmt 0 view .LVU173
 529 00ca E091 0000 		lds r30,matrix_prev
 530 00ce F091 0000 		lds r31,matrix_prev+1
 531 00d2 EC0F      		add r30,r28
 532 00d4 FD1F      		adc r31,r29
 533 00d6 8081      		ld r24,Z
 534               		.loc 3 114 29 view .LVU174
 535 00d8 4C0F      		add r20,r28
 536 00da 5D1F      		adc r21,r29
 537 00dc FA01      		movw r30,r20
 538 00de 8083      		st Z,r24
 539               	.L11:
 115:matrix.c      ****             }
 116:matrix.c      **** 
 117:matrix.c      ****             _delay_us(5);
 540               		.loc 3 117 13 is_stmt 1 discriminator 2 view .LVU175
 541               	.LVL30:
 542               	.LBB98:
 543               	.LBI98:
 255:/usr/avr/include/util/delay.h **** {
 544               		.loc 2 255 1 discriminator 2 view .LVU176
 545               	.LBB99:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 546               		.loc 2 257 2 discriminator 2 view .LVU177
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 547               		.loc 2 261 2 discriminator 2 view .LVU178
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 548               		.loc 2 262 2 discriminator 2 view .LVU179
 263:/usr/avr/include/util/delay.h **** 
 549               		.loc 2 263 2 discriminator 2 view .LVU180
 273:/usr/avr/include/util/delay.h **** 	#endif
 550               		.loc 2 273 3 discriminator 2 view .LVU181
 551               		.loc 2 276 2 discriminator 2 view .LVU182
 552 00e0 FAE1      		ldi r31,lo8(26)
 553 00e2 FA95      	1:	dec r31
 554 00e4 01F4      		brne 1b
 555 00e6 00C0      		rjmp .
 556               	.LVL31:
 557               		.loc 2 276 2 is_stmt 0 discriminator 2 view .LVU183
 558               	.LBE99:
 559               	.LBE98:
 118:matrix.c      ****             KEY_PREV_OFF();
 560               		.loc 3 118 13 is_stmt 1 discriminator 2 view .LVU184
 561               	.LBB100:
 562               	.LBI100:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 563               		.loc 1 43 20 discriminator 2 view .LVU185
 564               	.LBB101:
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 565               		.loc 1 43 41 discriminator 2 view .LVU186
  43:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
 566               		.loc 1 43 48 is_stmt 0 discriminator 2 view .LVU187
 567 00e8 2F98      		cbi 0x5,7
 568               	.LBE101:
 569               	.LBE100:
 119:matrix.c      ****             KEY_UNABLE();
 570               		.loc 3 119 13 is_stmt 1 discriminator 2 view .LVU188
 571               	.LBB102:
 572               	.LBI102:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
 573               		.loc 1 40 20 discriminator 2 view .LVU189
 574               	.LBB103:
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
 575               		.loc 1 40 39 discriminator 2 view .LVU190
  40:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
 576               		.loc 1 40 46 is_stmt 0 discriminator 2 view .LVU191
 577 00ea 2E9A      		sbi 0x5,6
 578               	.LBE103:
 579               	.LBE102:
 120:matrix.c      **** 
 121:matrix.c      ****             // NOTE: KEY_STATE keep its state in 20us after KEY_ENABLE.
 122:matrix.c      ****             // This takes 25us or more to make sure KEY_STATE returns to idle state.
 123:matrix.c      **** #ifdef HHKB_JP
 124:matrix.c      ****             // Looks like JP needs faster scan due to its twice larger matrix
 125:matrix.c      ****             // or it can drop keys in fast key typing
 126:matrix.c      ****             _delay_us(30);
 127:matrix.c      **** #else
 128:matrix.c      ****             _delay_us(75);
 580               		.loc 3 128 13 is_stmt 1 discriminator 2 view .LVU192
 581               	.LVL32:
 582               	.LBB104:
 583               	.LBI104:
 255:/usr/avr/include/util/delay.h **** {
 584               		.loc 2 255 1 discriminator 2 view .LVU193
 585               	.LBB105:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 586               		.loc 2 257 2 discriminator 2 view .LVU194
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 587               		.loc 2 261 2 discriminator 2 view .LVU195
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 588               		.loc 2 262 2 discriminator 2 view .LVU196
 263:/usr/avr/include/util/delay.h **** 
 589               		.loc 2 263 2 discriminator 2 view .LVU197
 273:/usr/avr/include/util/delay.h **** 	#endif
 590               		.loc 2 273 3 discriminator 2 view .LVU198
 591               		.loc 2 276 2 discriminator 2 view .LVU199
 592 00ec 8BE2      		ldi r24,lo8(299)
 593 00ee 91E0      		ldi r25,hi8(299)
 594 00f0 0197      	1:	sbiw r24,1
 595 00f2 01F4      		brne 1b
 596 00f4 00C0      		rjmp .
 597 00f6 0000      		nop
 598               	.LVL33:
 599               		.loc 2 276 2 is_stmt 0 discriminator 2 view .LVU200
 600 00f8 2F5F      		subi r18,-1
 601 00fa 3F4F      		sbci r19,-1
 602               	.LVL34:
 603               		.loc 2 276 2 discriminator 2 view .LVU201
 604 00fc 685F      		subi r22,lo8(-(8))
 605               	.LBE105:
 606               	.LBE104:
 607               	.LBE106:
  73:matrix.c      ****             KEY_SELECT(row, col);
 608               		.loc 3 73 9 discriminator 2 view .LVU202
 609 00fe 2830      		cpi r18,8
 610 0100 3105      		cpc r19,__zero_reg__
 611 0102 01F0      		breq .+2
 612 0104 00C0      		rjmp .L12
 613               	.LBE108:
 129:matrix.c      **** #endif
 130:matrix.c      ****         }
 131:matrix.c      ****         if (matrix[row] ^ matrix_prev[row]) matrix_last_modified = timer_read32();
 614               		.loc 3 131 9 is_stmt 1 view .LVU203
 615               		.loc 3 131 19 is_stmt 0 view .LVU204
 616 0106 A091 0000 		lds r26,matrix
 617 010a B091 0000 		lds r27,matrix+1
 618 010e AC0F      		add r26,r28
 619 0110 BD1F      		adc r27,r29
 620               		.loc 3 131 38 view .LVU205
 621 0112 E091 0000 		lds r30,matrix_prev
 622 0116 F091 0000 		lds r31,matrix_prev+1
 623 011a EC0F      		add r30,r28
 624 011c FD1F      		adc r31,r29
 625               		.loc 3 131 12 view .LVU206
 626 011e 9C91      		ld r25,X
 627 0120 8081      		ld r24,Z
 628 0122 9817      		cp r25,r24
 629 0124 01F0      		breq .L13
 630               		.loc 3 131 45 is_stmt 1 discriminator 1 view .LVU207
 631               		.loc 3 131 68 is_stmt 0 discriminator 1 view .LVU208
 632 0126 0E94 0000 		call timer_read32
 633               	.LVL35:
 634               		.loc 3 131 66 discriminator 1 view .LVU209
 635 012a 6093 0000 		sts matrix_last_modified,r22
 636 012e 7093 0000 		sts matrix_last_modified+1,r23
 637 0132 8093 0000 		sts matrix_last_modified+2,r24
 638 0136 9093 0000 		sts matrix_last_modified+3,r25
 639               	.L13:
 640               	.LVL36:
 641               		.loc 3 131 66 discriminator 1 view .LVU210
 642 013a 2196      		adiw r28,1
 643               	.LVL37:
  72:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
 644               		.loc 3 72 5 discriminator 2 view .LVU211
 645 013c C830      		cpi r28,8
 646 013e D105      		cpc r29,__zero_reg__
 647 0140 01F0      		breq .+2
 648 0142 00C0      		rjmp .L14
 649               	.LBE110:
 132:matrix.c      ****     }
 133:matrix.c      ****     // power off
 134:matrix.c      ****     if (KEY_POWER_STATE() &&
 650               		.loc 3 134 5 is_stmt 1 view .LVU212
 651               	.LBB111:
 652               	.LBI111:
  56:hhkb_avr.h    **** #else
 653               		.loc 1 56 20 view .LVU213
 654               	.LBB112:
  56:hhkb_avr.h    **** #else
 655               		.loc 1 56 44 view .LVU214
 656               	.LBE112:
 657               	.LBE111:
 658               		.loc 3 134 8 is_stmt 0 view .LVU215
 659 0144 5C9B      		sbis 0xb,4
 660 0146 00C0      		rjmp .L17
 135:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 661               		.loc 3 135 30 discriminator 1 view .LVU216
 662 0148 8091 0000 		lds r24,USB_DeviceState
 134:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 663               		.loc 3 134 27 discriminator 1 view .LVU217
 664 014c 8530      		cpi r24,lo8(5)
 665 014e 01F0      		breq .L18
 136:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 666               		.loc 3 136 30 view .LVU218
 667 0150 8091 0000 		lds r24,USB_DeviceState
 135:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 668               		.loc 3 135 56 view .LVU219
 669 0154 8111      		cpse r24,__zero_reg__
 670 0156 00C0      		rjmp .L17
 671               	.L18:
 137:matrix.c      ****             timer_elapsed32(matrix_last_modified) > MATRIX_POWER_SAVE) {
 672               		.loc 3 137 13 view .LVU220
 673 0158 6091 0000 		lds r22,matrix_last_modified
 674 015c 7091 0000 		lds r23,matrix_last_modified+1
 675 0160 8091 0000 		lds r24,matrix_last_modified+2
 676 0164 9091 0000 		lds r25,matrix_last_modified+3
 677 0168 0E94 0000 		call timer_elapsed32
 678               	.LVL38:
 136:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 679               		.loc 3 136 59 view .LVU221
 680 016c 6131      		cpi r22,17
 681 016e 7742      		sbci r23,39
 682 0170 8105      		cpc r24,__zero_reg__
 683 0172 9105      		cpc r25,__zero_reg__
 684 0174 00F0      		brlo .L17
 138:matrix.c      ****         KEY_POWER_OFF();
 685               		.loc 3 138 9 is_stmt 1 view .LVU222
 686 0176 0E94 0000 		call KEY_POWER_OFF
 687               	.LVL39:
 139:matrix.c      ****         suspend_power_down();
 688               		.loc 3 139 9 view .LVU223
 689 017a 0E94 0000 		call suspend_power_down
 690               	.LVL40:
 691               	.L17:
 140:matrix.c      ****     }
 141:matrix.c      ****     return 1;
 692               		.loc 3 141 5 view .LVU224
 142:matrix.c      **** }
 693               		.loc 3 142 1 is_stmt 0 view .LVU225
 694 017e 81E0      		ldi r24,lo8(1)
 695               	/* epilogue start */
 696 0180 DF91      		pop r29
 697 0182 CF91      		pop r28
 698               	.LVL41:
 699               		.loc 3 142 1 view .LVU226
 700 0184 1F91      		pop r17
 701 0186 0F91      		pop r16
 702 0188 FF90      		pop r15
 703 018a EF90      		pop r14
 704 018c 0895      		ret
 705               	.LVL42:
 706               	.L7:
 707               	.LBB113:
 708               	.LBB109:
 709               	.LBB107:
 107:matrix.c      ****             }
 710               		.loc 3 107 17 is_stmt 1 view .LVU227
 107:matrix.c      ****             }
 711               		.loc 3 107 29 is_stmt 0 view .LVU228
 712 018e 9081      		ld r25,Z
 713 0190 892B      		or r24,r25
 714 0192 00C0      		rjmp .L29
 715               	.L9:
 113:matrix.c      ****                 matrix[row] = matrix_prev[row];
 716               		.loc 3 113 17 discriminator 2 view .LVU229
 717 0194 86B5      		in r24,0x26
 718 0196 D701      		movw r26,r14
 719 0198 AE1B      		sub r26,r30
 720 019a BF0B      		sbc r27,r31
 721 019c 8A0F      		add r24,r26
 722 019e 9B2F      		mov r25,r27
 723 01a0 911D      		adc r25,__zero_reg__
 724 01a2 00C0      		rjmp .L10
 725               	.LBE107:
 726               	.LBE109:
 727               	.LBE113:
 728               		.cfi_endproc
 729               	.LFE116:
 731               		.section	.text.matrix_get_row,"ax",@progbits
 732               	.global	matrix_get_row
 734               	matrix_get_row:
 735               	.LVL43:
 736               	.LFB117:
 143:matrix.c      **** 
 144:matrix.c      **** inline
 145:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 146:matrix.c      **** {
 737               		.loc 3 146 1 is_stmt 1 view -0
 738               		.cfi_startproc
 739               	/* prologue: function */
 740               	/* frame size = 0 */
 741               	/* stack size = 0 */
 742               	.L__stack_usage = 0
 147:matrix.c      ****     return matrix[row];
 743               		.loc 3 147 5 view .LVU231
 744               		.loc 3 147 18 is_stmt 0 view .LVU232
 745 0000 2091 0000 		lds r18,matrix
 746 0004 3091 0000 		lds r19,matrix+1
 747 0008 820F      		add r24,r18
 748 000a 932F      		mov r25,r19
 749 000c 911D      		adc r25,__zero_reg__
 750               	.LVL44:
 148:matrix.c      **** }
 751               		.loc 3 148 1 view .LVU233
 752 000e FC01      		movw r30,r24
 753 0010 8081      		ld r24,Z
 754               	/* epilogue start */
 755 0012 0895      		ret
 756               		.cfi_endproc
 757               	.LFE117:
 759               		.section	.text.matrix_power_up,"ax",@progbits
 760               	.global	matrix_power_up
 762               	matrix_power_up:
 763               	.LFB118:
 149:matrix.c      **** 
 150:matrix.c      **** void matrix_power_up(void) {
 764               		.loc 3 150 28 is_stmt 1 view -0
 765               		.cfi_startproc
 766               	/* prologue: function */
 767               	/* frame size = 0 */
 768               	/* stack size = 0 */
 769               	.L__stack_usage = 0
 151:matrix.c      ****     KEY_POWER_ON();
 770               		.loc 3 151 5 view .LVU235
 771 0000 0C94 0000 		jmp KEY_POWER_ON
 772               	.LVL45:
 773               		.cfi_endproc
 774               	.LFE118:
 776               		.section	.text.matrix_power_down,"ax",@progbits
 777               	.global	matrix_power_down
 779               	matrix_power_down:
 780               	.LFB119:
 152:matrix.c      **** }
 153:matrix.c      **** void matrix_power_down(void) {
 781               		.loc 3 153 30 view -0
 782               		.cfi_startproc
 783               	/* prologue: function */
 784               	/* frame size = 0 */
 785               	/* stack size = 0 */
 786               	.L__stack_usage = 0
 154:matrix.c      ****     KEY_POWER_OFF();
 787               		.loc 3 154 5 view .LVU237
 788 0000 0C94 0000 		jmp KEY_POWER_OFF
 789               	.LVL46:
 790               		.cfi_endproc
 791               	.LFE119:
 793               		.section	.bss._matrix1,"aw",@nobits
 796               	_matrix1:
 797 0000 0000 0000 		.zero	8
 797      0000 0000 
 798               		.section	.bss._matrix0,"aw",@nobits
 801               	_matrix0:
 802 0000 0000 0000 		.zero	8
 802      0000 0000 
 803               		.section	.bss.matrix_prev,"aw",@nobits
 806               	matrix_prev:
 807 0000 0000      		.zero	2
 808               		.section	.bss.matrix,"aw",@nobits
 811               	matrix:
 812 0000 0000      		.zero	2
 813               		.section	.bss.matrix_last_modified,"aw",@nobits
 816               	matrix_last_modified:
 817 0000 0000 0000 		.zero	4
 818               		.text
 819               	.Letext0:
 820               		.file 4 "/usr/avr/include/stdint.h"
 821               		.file 5 "../../tmk_core/common/debug.h"
 822               		.file 6 "../../tmk_core/common/avr/xprintf.h"
 823               		.file 7 "../../tmk_core/common/timer.h"
 824               		.file 8 "../../tmk_core/common/matrix.h"
 825               		.file 9 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 826               		.file 10 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 827               		.file 11 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 828               		.file 12 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/HostStandardReq.h"
 829               		.file 13 "/usr/avr/include/stdio.h"
 830               		.file 14 "../../tmk_core/common/report.h"
 831               		.file 15 "../../tmk_core/common/host_driver.h"
 832               		.file 16 "../../tmk_core/common/host.h"
 833               		.file 17 "../../tmk_core/protocol/lufa/lufa.h"
 834               		.file 18 "../../tmk_core/common/suspend.h"
 835               		.file 19 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../Device.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccYIy78Q.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYIy78Q.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYIy78Q.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYIy78Q.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYIy78Q.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYIy78Q.s:12     .text.KEY_POWER_OFF:0000000000000000 KEY_POWER_OFF
     /tmp/ccYIy78Q.s:42     .text.KEY_POWER_ON:0000000000000000 KEY_POWER_ON
     /tmp/ccYIy78Q.s:96     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccYIy78Q.s:801    .bss._matrix0:0000000000000000 _matrix0
     /tmp/ccYIy78Q.s:796    .bss._matrix1:0000000000000000 _matrix1
     /tmp/ccYIy78Q.s:811    .bss.matrix:0000000000000000 matrix
     /tmp/ccYIy78Q.s:806    .bss.matrix_prev:0000000000000000 matrix_prev
     /tmp/ccYIy78Q.s:265    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccYIy78Q.s:816    .bss.matrix_last_modified:0000000000000000 matrix_last_modified
     /tmp/ccYIy78Q.s:734    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccYIy78Q.s:762    .text.matrix_power_up:0000000000000000 matrix_power_up
     /tmp/ccYIy78Q.s:779    .text.matrix_power_down:0000000000000000 matrix_power_down

UNDEFINED SYMBOLS
timer_read32
USB_DeviceState
timer_elapsed32
suspend_power_down
__do_clear_bss
